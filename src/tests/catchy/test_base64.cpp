// (C) 2015 Simon Warta (Kullo GmbH)
// Botan is released under the Simplified BSD License (see license.txt)

#include "catch.hpp"

#include <botan/build.h>

#if defined(BOTAN_HAS_BASE64_CODEC)

#include <botan/base64.h>

namespace {
std::vector<Botan::byte> toStdVector(const Botan::secure_vector<Botan::byte> &in)
   {
   return std::vector<Botan::byte>(in.cbegin(), in.cend());
   }

std::vector<Botan::byte> toStdVector(const std::string &in)
   {
   return std::vector<Botan::byte>(in.cbegin(), in.cend());
   }
}

TEST_CASE("Base64 encode empty string", "[base64]")
   {
   // common knowledge
   auto emptyString = std::string("");
   auto emptyVector = std::vector<Botan::byte>(emptyString.cbegin(), emptyString.cend());
   CHECK(( Botan::base64_encode(emptyVector) == "" ));
   }

TEST_CASE("Base64 encode short string", "[base64]")
   {
   // test vectors from http://tools.ietf.org/html/rfc4648
   auto in1 = std::vector<Botan::byte>{ 'f' };
   auto in2 = std::vector<Botan::byte>{ 'f', 'o' };
   auto in3 = std::vector<Botan::byte>{ 'f', 'o', 'o' };
   CHECK(( Botan::base64_encode(in1) == "Zg==" ));
   CHECK(( Botan::base64_encode(in2) == "Zm8=" ));
   CHECK(( Botan::base64_encode(in3) == "Zm9v" ));
   }

TEST_CASE("Base64 encode string", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = std::vector<Botan::byte>{ 'h','e','l','l','o',' ','w','o','r','l','d' };
   auto in2 = std::vector<Botan::byte>{ 'h','e','l','l','o',' ','w','o','r','l','d','!' };
   auto in3 = std::vector<Botan::byte>{ 'H','e','l','l','o',',',' ','w','o','r','l','d','.' };
   auto in4 = std::vector<Botan::byte>{ 'T','h','e',' ','1','2',' ','c','h','a','r','s' };
   auto in5 = std::vector<Botan::byte>{ 'T','h','e',' ','1','3',' ','c','h','a','r','s','.' };
   auto in6 = std::vector<Botan::byte>{ 'T','h','e',' ','1','4',' ','c','h','a','r','s','.','.' };
   auto in7 = std::vector<Botan::byte>{ 'T','h','e',' ','1','5',' ','c','h','a','r','s','.','.','.' };
   CHECK(( Botan::base64_encode(in1) == "aGVsbG8gd29ybGQ=" ));
   CHECK(( Botan::base64_encode(in2) == "aGVsbG8gd29ybGQh" ));
   CHECK(( Botan::base64_encode(in3) == "SGVsbG8sIHdvcmxkLg==" ));
   CHECK(( Botan::base64_encode(in4) == "VGhlIDEyIGNoYXJz" ));
   CHECK(( Botan::base64_encode(in5) == "VGhlIDEzIGNoYXJzLg==" ));
   CHECK(( Botan::base64_encode(in6) == "VGhlIDE0IGNoYXJzLi4=" ));
   CHECK(( Botan::base64_encode(in7) == "VGhlIDE1IGNoYXJzLi4u" ));
   }

TEST_CASE("Base64 encode string special chars", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = toStdVector("An UTF-8 uuml: ü");
   auto in2 = toStdVector("Weird German 2 byte thing: ß.");
   CHECK(( Botan::base64_encode(in1) == "QW4gVVRGLTggdXVtbDogw7w=" ));
   CHECK(( Botan::base64_encode(in2) == "V2VpcmQgR2VybWFuIDIgYnl0ZSB0aGluZzogw58u" ));
   }

TEST_CASE("Base64 encode empty binary", "[base64]")
   {
   auto binary0 = std::vector<unsigned char>{};
   CHECK(( Botan::base64_encode(binary0) == "" ));
   }

TEST_CASE("Base64 encode binary", "[base64]")
   {
   // Generated by: cat /dev/urandom | head -c 3 | tee /tmp/mybinary | hexdump -C && cat /tmp/mybinary | base64
   std::vector<unsigned char> binary1 = {0x9b};
   CHECK(( Botan::base64_encode(binary1) == "mw==" ));

   std::vector<unsigned char> binary2 = {0x1c, 0x60};
   CHECK(( Botan::base64_encode(binary2) == "HGA=" ));

   std::vector<unsigned char> binary3 = {0x81, 0x34, 0xbd};
   CHECK(( Botan::base64_encode(binary3) == "gTS9" ));

   std::vector<unsigned char> binary4 = {0x5e, 0x6c, 0xff, 0xde};
   CHECK(( Botan::base64_encode(binary4) == "Xmz/3g==" ));

   std::vector<unsigned char> binary5 = {0xb2, 0xcd, 0xf0, 0xdc, 0x7f};
   CHECK(( Botan::base64_encode(binary5) == "ss3w3H8=" ));

   std::vector<unsigned char> binary6 = {0xfc, 0x56, 0x2d, 0xda, 0xd4, 0x0e};
   CHECK(( Botan::base64_encode(binary6) == "/FYt2tQO" ));

   std::vector<unsigned char> binary7 = {0x29, 0xb2, 0x32, 0x2e, 0x88, 0x41, 0xe8};
   CHECK(( Botan::base64_encode(binary7) == "KbIyLohB6A==" ));

   std::vector<unsigned char> binary8 = {0x0f, 0x0f, 0xce, 0xd9, 0x49, 0x7a, 0xaf, 0x92};
   CHECK(( Botan::base64_encode(binary8) == "Dw/O2Ul6r5I=" ));

   std::vector<unsigned char> binary9 = {0x27, 0x0f, 0xb1, 0x89, 0x82, 0x80, 0x0d, 0xa6, 0x40};
   CHECK(( Botan::base64_encode(binary9) == "Jw+xiYKADaZA" ));
   }

TEST_CASE("Base64 decode empty string", "[base64]")
   {
   // common knowledge
   auto outVector = toStdVector(Botan::base64_decode(""));
   CHECK(( outVector == std::vector<Botan::byte>{} ));
   }

TEST_CASE("Base64 decode short string", "[base64]")
   {
   // test vectors from http://tools.ietf.org/html/rfc4648
   CHECK(( toStdVector(Botan::base64_decode("Zg==")) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode("Zm8=")) == toStdVector("fo") ));
   CHECK(( toStdVector(Botan::base64_decode("Zm9v")) == toStdVector("foo") ));
   }

TEST_CASE("Base64 decode string", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   CHECK(( toStdVector(Botan::base64_decode("aGVsbG8gd29ybGQ="))     == toStdVector("hello world") ));
   CHECK(( toStdVector(Botan::base64_decode("aGVsbG8gd29ybGQh"))     == toStdVector("hello world!") ));
   CHECK(( toStdVector(Botan::base64_decode("SGVsbG8sIHdvcmxkLg==")) == toStdVector("Hello, world.") ));
   CHECK(( toStdVector(Botan::base64_decode("VGhlIDEyIGNoYXJz"))     == toStdVector("The 12 chars") ));
   CHECK(( toStdVector(Botan::base64_decode("VGhlIDEzIGNoYXJzLg==")) == toStdVector("The 13 chars.") ));
   CHECK(( toStdVector(Botan::base64_decode("VGhlIDE0IGNoYXJzLi4=")) == toStdVector("The 14 chars..") ));
   CHECK(( toStdVector(Botan::base64_decode("VGhlIDE1IGNoYXJzLi4u")) == toStdVector("The 15 chars...") ));
   }

TEST_CASE("Base64 decode string special chars", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = std::string("QW4gVVRGLTggdXVtbDogw7w=");
   auto in2 = std::string("V2VpcmQgR2VybWFuIDIgYnl0ZSB0aGluZzogw58u");
   auto out1 = std::string("An UTF-8 uuml: ü");
   auto out2 = std::string("Weird German 2 byte thing: ß.");
   CHECK(( toStdVector(Botan::base64_decode(in1)) == toStdVector(out1) ));
   CHECK(( toStdVector(Botan::base64_decode(in2)) == toStdVector(out2) ));
   }

TEST_CASE("Base64 decode binary", "[base64]")
   {
   // Generated by: cat /dev/urandom | head -c 3 | tee /tmp/mybinary | hexdump -C && cat /tmp/mybinary | base64
   std::vector<unsigned char> binary0 = {};
   CHECK(( toStdVector(Botan::base64_decode("")) == binary0));

   std::vector<unsigned char> binary1 = {0x9b};
   CHECK(( toStdVector(Botan::base64_decode("mw==")) == binary1 ));

   std::vector<unsigned char> binary2 = {0x1c, 0x60};
   CHECK(( toStdVector(Botan::base64_decode("HGA=")) == binary2 ));

   std::vector<unsigned char> binary3 = {0x81, 0x34, 0xbd};
   CHECK(( toStdVector(Botan::base64_decode("gTS9")) == binary3 ));

   std::vector<unsigned char> binary4 = {0x5e, 0x6c, 0xff, 0xde};
   CHECK(( toStdVector(Botan::base64_decode("Xmz/3g==")) == binary4 ));

   std::vector<unsigned char> binary5 = {0xb2, 0xcd, 0xf0, 0xdc, 0x7f};
   CHECK(( toStdVector(Botan::base64_decode("ss3w3H8=")) == binary5 ));

   std::vector<unsigned char> binary6 = {0xfc, 0x56, 0x2d, 0xda, 0xd4, 0x0e};
   CHECK(( toStdVector(Botan::base64_decode("/FYt2tQO")) == binary6 ));

   std::vector<unsigned char> binary7 = {0x29, 0xb2, 0x32, 0x2e, 0x88, 0x41, 0xe8};
   CHECK(( toStdVector(Botan::base64_decode("KbIyLohB6A==")) == binary7 ));

   std::vector<unsigned char> binary8 = {0x0f, 0x0f, 0xce, 0xd9, 0x49, 0x7a, 0xaf, 0x92};
   CHECK(( toStdVector(Botan::base64_decode("Dw/O2Ul6r5I=")) == binary8 ));

   std::vector<unsigned char> binary9 = {0x27, 0x0f, 0xb1, 0x89, 0x82, 0x80, 0x0d, 0xa6, 0x40};
   CHECK(( toStdVector(Botan::base64_decode("Jw+xiYKADaZA")) == binary9 ));
   }

TEST_CASE("Base64 decode and ignore whitespace", "[base64]")
   {
   CHECK(( toStdVector(Botan::base64_decode(std::string(" Zg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Z g=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg =="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg= ="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg== "), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\rZg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\nZg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\tZg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\r=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\n=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\t=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\r"), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\n"), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\t"), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\r Zg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\n Zg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("\t Zg=="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\r =="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\n =="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg\t =="), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\r "), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\n "), true)) == toStdVector("f") ));
   CHECK(( toStdVector(Botan::base64_decode(std::string("Zg==\t "), true)) == toStdVector("f") ));
   }

TEST_CASE("Base64 decode and don't ignore whitespace", "[base64]")
   {
   CHECK_THROWS( Botan::base64_decode(std::string(" Zg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Z g=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg =="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg= ="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg== "), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\rZg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\nZg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\tZg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\r=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\n=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\t=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\r"), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\n"), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\t"), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\r Zg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\n Zg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("\t Zg=="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\r =="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\n =="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg\t =="), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\r "), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\n "), false) );
   CHECK_THROWS( Botan::base64_decode(std::string("Zg==\t "), false) );
   }

#endif // BOTAN_HAS_BASE64_CODEC
